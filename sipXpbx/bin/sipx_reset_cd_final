#! /usr/bin/env python

#----------------------------------------------------------------------
#
# Copyright (C) 2007 Pingtel Corp., certain elements licensed under a Contributor Agreement.  
# Contributors retain copyright to elements licensed under a Contributor Agreement.
# Licensed to the User under the LGPL license.
#
# Author:  Andrew Golovanov
#
# This script reconfigures finalizes SIPX installation on post-anaconda
# step (i.e. after the first host reboot), and is supposed to be executed
# on a linux host that was pre-installed using a SIPX Installation CD.
#
# Following linux parameters may be reconfigured by this script:
#
#    - root password
#    - time zone
#
# In addition to these parameters, the script does the following:
#
#    - optionally configures and starts NTP
#    - installs and starts PostgreSQL server
#    - creates a new database
#    - installs a default self-signed SSL certificate
#    - starts SIPX
#
#----------------------------------------------------------------------

import os, commands, sys, sre, time, traceback, glob, signal

hlpMsg  = '\nThere are currently no command line options supported by this script'

admin_email = ''
#--- Local constants

RHELCFGLIST        = ['ip', 'hostname', 'netmask', 'gateway', 'nameserver', 'password', 'timezone']
                                                           # List of supported RHEL configuration parameters
RHELCFGFILES       = ['/etc/sysconfig/network', '/etc/hosts', '/etc/resolv.conf', '/etc/sysconfig/clock']
                                                           # List of modified RHEL configuration files
RHELPSWFILES       = ['/etc/group', '/etc/passwd', '/etc/shadow', '/etc/gshadow']
                                                           # List of password-related RHEL files
ALREADYUPDATEDLIST = list ()
RECROOTDIR  = '/recovery'                                  # Root directory of recovery partition
IFCONFIGDIR = '/etc/sysconfig/network-scripts'             # Directory of all interface configurations
ETHNAME     = 'eth0'                                       # Supported Ethernet interface
ZONEDIR     = '/usr/share/zoneinfo'                        # Directory with timezone files
RUNLEVEL    = 3                                            # Always use this runlevel
OUTPUT_LOG  = './output.log'

reCMDOPT    = sre.compile ('(^|\s+)-+')
reHOSTNAME  = sre.compile ('^HOSTNAME=(\S*)',     sre.M)   # Host name in the /etc/sysconfig/network file
reIPADDR    = sre.compile ('^IPADDR=(\S*)',       sre.M)   # IP address in the ifcfg-eth<n> file
reIPMASK    = sre.compile ('^NETMASK=(\S*)',      sre.M)   # IP mask in the ifcfg-eth<n> file
reBROAD     = sre.compile ('^BROADCAST=(\S*)',    sre.M)   # Broadcast IP address in the ifcfg-eth<n> file
reNETWORK   = sre.compile ('^NETWORK=(\S*)',      sre.M)   # Network IP address in the ifcfg-eth<n> file
reGATEWAY   = sre.compile ('^GATEWAY=(\S*)',      sre.M)   # Gateway IP address in the /etc/sysconfig/network file
reMAILADMIN   = sre.compile ('^root: (\S*)',      sre.M)   # Gateway IP address in the /etc/sysconfig/network file
reDOMAIN    = sre.compile ('^search\s+(\S*)',     sre.M)   # Domain name in the /etc/resolv.conf file
reDNSNAME   = sre.compile ('^nameserver\s+(\S*)', sre.M)   # DNS name in the /etc/resolv.conf file
reZONE      = sre.compile ('^ZONE="([^"]*)"',     sre.M)   # Zone name in the /etc/sysconfig/clock file

#global file-handler for login purposes

global fout
global screen
global pb
import snack

def log_init ():
    global fout
    fout=open(OUTPUT_LOG,"w")
    
def log_printout (outString):
    global fout
    fout.write(outString + "\n")
    
def log_destroy ():
    global fout
    fout.close

def screen_init ():
    global screen
    screen = snack.SnackScreen()

def screen_err (outString):
    global screen
    sg = snack.GridForm(screen, 'ERROR', 50, 12)
    b=snack.Button("Exit")
    t=snack.Textbox(45, 8, "", 1, 1)
    t.setText(outString)
    sg.add(b, 1, 2)
    sg.add(t, 1, 1)
    sg.runOnce()
    screen.finish()
    
def screen_destroy ():
    global screen
    screen.finish()

def raiseCleanExit (outString):
    log_printout (outString)
    log_destroy ()
    screen_err(outString)
    raise SystemExit

def progress(i):
    global pb
    global screen
    pb.set(i)
    screen.refresh()
    time.sleep(1)    

def screen_completed ():
    global screen
    sg = snack.GridForm(screen, 'SUCCESS', 1, 4)
    b=snack.Button("OK")
    t=snack.TextboxReflowed(40,  "         Instalation SUCCESS !!!      ", 0, 0)
    t2=snack.TextboxReflowed(40, "   Computer will reboot   ", 0, 0)
    l=snack.Label(" ")
    sg.add(t, 0, 0)
    sg.add(t2, 0, 1)
    sg.add(l, 0, 2)
    sg.add(b, 0, 3)
    sg.runOnce()
    screen.finish()
    
def screen_ask_net (keyValues):
	global screen
	global admin_email
	
	b1 = snack.Button("   OK   ")
	b2 = snack.Button("Restore")
	
	res=b2
	
	admin_email = mailadmin()
	
	while res != b1 :
		sg = snack.Grid(3, 9)
		l0 = snack.Label(" ")
		l1 = snack.Label("Hostname:   ")
		e1 = snack.Entry(20, keyValues["hostname"])
		l2 = snack.Label("Ip:         ")
		e2 = snack.Entry(20, keyValues["ip"])
		l3 = snack.Label("Netmask:    ")
		e3 = snack.Entry(20, keyValues["netmask"])
		l4 = snack.Label("Gateway:    ")
		e4 = snack.Entry(20, keyValues["gateway"])
		l5 = snack.Label("Nameserver: ")
		e5 = snack.Entry(20, keyValues["nameserver"])
		l6 = snack.Label("Password:   ")
		e6 = snack.Entry(20, keyValues["password"], 0, 1)
		l7 = snack.Label("Admin email:")
		e7 = snack.Entry(20,  admin_email )
		sg.setField(l1, 0, 0)
		sg.setField(e1, 1, 0)
		sg.setField(l2, 0, 1)
		sg.setField(e2, 1, 1)
		sg.setField(l3, 0, 2)
		sg.setField(e3, 1, 2)
		sg.setField(l4, 0, 3)
		sg.setField(e4, 1, 3)
		sg.setField(l5, 0, 4)
		sg.setField(e5, 1, 4)
		sg.setField(l6, 0, 5)
		sg.setField(e6, 1, 5)
		sg.setField(l7, 0, 6)
		sg.setField(e7, 1, 6)
		sg.setField(l0, 0, 7)
		sg.setField(b1, 0, 8)
		sg.setField(b2, 1, 8)
		
		sg.place(1,1)
		screen.gridWrappedWindow(sg, "Please enter your network parameters:")
		f = snack.Form()
		f.add(sg)
		res = f.run()
		f.draw()
		screen.refresh()
	
	NewValues=dict()
	NewValues['hostname']=e1.value()
	NewValues['ip']=e2.value()
	NewValues['netmask']=e3.value()
	NewValues['gateway']=e4.value()
	NewValues['nameserver']=e5.value()
	NewValues['password']=e6.value()
	admin_email=e7.value()
	
	return NewValues
	
def screen_ask_ntp ():
	global screen
	flg=0
	
	screen.popWindow()
	
	sg = snack.Grid(1, 2)
	bb = snack.ButtonBar(screen, (("  YES  ", "ok"), ("no", "cancel")) )
	te = snack.Textbox(36,3,"Would do you like to configure NTP?",0,1)
	sg.setField(te, 0, 0)
	sg.setField(bb, 0, 1)
	sg.place(1,1)
	screen.gridWrappedWindow(sg, "NTP settings:")
	f = snack.Form()
	f.add(sg)
	res = f.run()
	
	if bb.buttonPressed(res) == "ok" : flg=1
	
	return flg

def screen_ask_tz (Name):
	global screen
	
	allTimeZoneList = _getListOfTimeZones ()
	lstLen = len (allTimeZoneList)
	
	screen.popWindow()
	
	out=-1
	while (out==-1):
		sg = snack.Grid(1, 2)
		b  = snack.Button("   OK   ")	
		ct = snack.CheckboxTree(10, scroll = 1)
	
		splitted = dict()
		for i in xrange (0, lstLen):
			splitted [i]  = allTimeZoneList[i].split("/")
		lastlvl=''
		boxlvl=-1
		for i in splitted:
			splm = splitted [i]
			tmplvl=splm[0]
			if tmplvl != lastlvl :
				boxlvl=boxlvl+1
				ct.append(tmplvl)
			lastlvl=tmplvl
			tmplst=''
			for k in splm:
				tmplst=tmplst+'/'+k
			level2=tmplst[1:]
			ct.addItem(level2, (boxlvl, snack.snackArgs['append']), i)
			if Name == level2:
				ctcur=i
		ct.setCurrent(ctcur)
		ct.setEntryValue(ctcur, selected=1)
		sg.setField(ct, 0, 0)
		sg.setField(b, 0, 1)
		sg.place(1,1)
		screen.gridWrappedWindow(sg, "Select your timezone:")
		f = snack.Form()
		f.add(sg)
		res = f.run()
		sel=ct.getSelection()
		if len(sel) == 1:
			out = sel[0]
		else:
			g = snack.GridForm(screen, "ERROR", 1, 2)
			if len(sel) == 0:
				te = snack.Textbox(26,3,"You must select something",0,1)
			if len(sel) > 1:
				te = snack.Textbox(27,3,"You need to select only one",0,1)
			g.add(te, 0, 0)
			g.add(snack.Button("Ok"), 0, 1)
			g.runOnce()
	
	return allTimeZoneList[out]

def screen_ask_confirm (keyValues, newVal, ntpFlag):
	global screen
	flg=0
	
	screen.popWindow()

	sg = snack.Grid(1, 12)
	bb = snack.ButtonBar(screen, (("  NO  ", "cancel"), ("yes", "ok")) )
	if newVal:
		te = snack.Textbox(50,4,"This is your last chance to avoid changes in these parameters. Please type 'yes' if you want to proceed with these changes",0,1)
	else:
		te = snack.Textbox(50,4,"There are no changes requested in parameters. Please type 'yes' if you want to proceed with the installation",0,1)

	if newVal.has_key("hostname") :
		tmp = "Hostname:   %20s" % newVal["hostname"]
	else:
		tmp = "Hostname:   %20s" % keyValues["hostname"]
	e1 = snack.Label(tmp)
	
	if newVal.has_key("ip") :
		tmp = "Ip:         %20s" % newVal["ip"]
	else:
		tmp = "Ip:         %20s" % keyValues["ip"]
	e2 = snack.Label(tmp)
	
	if newVal.has_key("netmask") :
		tmp = "Netmask:    %20s" % newVal["netmask"]
	else:
		tmp = "Netmask:    %20s" % keyValues["netmask"]
	e3 = snack.Label(tmp)
	
	if newVal.has_key("gateway") :
		tmp = "Gateway:    %20s" % newVal["gateway"]
	else:
		tmp = "Gateway:    %20s" % keyValues["gateway"]
	e4 = snack.Label(tmp)
	
	if newVal.has_key("nameserver") :
		tmp = "Nameserver: %20s" % newVal["nameserver"]
	else:
		tmp = "Nameserver: %20s" % keyValues["nameserver"]
	e5 = snack.Label(tmp)
	
	if newVal.has_key("password") :
		tmp = "Password:   %20s" % newVal["password"]
	else:
		tmp = "Password:   %20s" % keyValues["password"]
	e6 = snack.Label(tmp)
	
	if newVal.has_key("timezone") :
		tmp = "Timezone:   %20s" % newVal["timezone"]
	else:
		tmp = "Timezone:   %20s" % keyValues["timezone"]
	e7 = snack.Label(tmp)

	if ntpFlag==1:
		tmp = "NTP config  %20s" % 'yes'
	else:
		tmp = "NTP config  %20s" % 'no'
	e8 = snack.Label(tmp)

	
	
	if admin_email:
		tmp = "Admin mail: %20s" % admin_email
	else:
		tmp = "Admin mail: %20s" % "(none)"
	e9 = snack.Label(tmp)
	
			
	e0 = snack.Label(" ")
	
	sg.setField(te, 0, 0)
	
	sg.setField(e1, 0, 1)
	sg.setField(e2, 0, 2)
	sg.setField(e3, 0, 3)
	sg.setField(e4, 0, 4)
	sg.setField(e5, 0, 5)
	sg.setField(e6, 0, 6)
	sg.setField(e8, 0, 7)
	sg.setField(e7, 0, 8)
	sg.setField(e9, 0, 9)
	
	sg.setField(e0, 0, 10)
	
	sg.setField(bb, 0, 11)
	
	sg.place(1,1)
	
	screen.gridWrappedWindow(sg, "WARNING")
	f = snack.Form()
	f.add(sg)
	res = f.run()
	
	if bb.buttonPressed(res) == "ok" : flg=1
	
	return flg

def hostname (fullHostName=None):
    """
    Gets/sets a full host name from/to the /etc/sysconfig/network file.
    In addition this procedure in the SET mode puts a host name
    into /etc/hosts and a domain name into the /etc/resolv.conf file.
    """

    global ALREADYUPDATEDLIST

    file1       = RHELCFGFILES [0]       # /etc/sysconfig/network
    file2       = RHELCFGFILES [1]       # /etc/hosts
    file3       = RHELCFGFILES [2]       # /etc/resolv.conf

    # Read file: /etc/sysconfig/network
    f1Cont      = file (file1).read()

    if fullHostName:

        # We are in the "set" mode
        # ------------------------

        if fullHostName.count('.') < 2:
            # We expect at least 2 dots in the new fully qualified host name
            raiseCleanExit ('\n*** Error: no domain detected in the full host name (%s) ***\n' % fullHostName)
        
        # Replace or add the line "HOSTNAME=..." with the new host name
        # in content of the file: /etc/sysconfig/network
        if reHOSTNAME.search (f1Cont):
            f1Cont = reHOSTNAME.sub ('HOSTNAME=%s' % fullHostName, f1Cont)   # replace ...
        else:
            f1Cont = f1Cont.strip() + '\nHOSTNAME=%s' % fullHostName         # add ...

        # Domain name == whatever follows the first dot
        domainName = '.'.join (fullHostName.split('.')[1:])

        # Rewrtie file: /etc/hosts
        f2Cont  = '# Do not remove the following line, or various programs\n'
        f2Cont += '# that require network functionality will fail.\n'
        f2Cont += '127.0.0.1 localhost.localdomain localhost\n'
        if 'ip' in newVal: ipAddr = newVal['ip'][0]
        else:              ipAddr = ip ()
        f2Cont += '%s %s %s\n' % (ipAddr, fullHostName, fullHostName.split('.')[0])

        # Read file: /etc/resolv.conf
        f3Cont  = file (file3).read()

        # Replace or add domain name in the file: /etc/resolv.conf
        if reDOMAIN.search (f3Cont):
            f3Cont = reDOMAIN.sub ('search %s' % domainName, f3Cont)         # replace ...
        else:
            f3Cont = f3Cont.strip() + '\nsearch %s' % domainName             # add ...

        # Output modified files
        file (file1, 'w').write(f1Cont)
        file (file2, 'w').write(f2Cont)
        file (file3, 'w').write(f3Cont)

        # Temporarily (until next reboot) set the new host name
        # to avoid the "Hostname lookup failure"
        cmdoutput=commands.getoutput ('hostname %s' % fullHostName)
        log_printout (cmdoutput)
        # Remember what we had updated
        ALREADYUPDATEDLIST.append ('hostname')
        
    else:
        
        # We are in the "get" mode
        # ------------------------
        
        # Just return a current hostname from the file: /etc/sysconfig/network
        mObj = reHOSTNAME.search(f1Cont)
        # it's ok if there is no hostname configured
        if not mObj:
            hostname=''
        else:
            hostname=mObj.group(1)
        return hostname

def ip (ipANDmask=None):
    """
    Updates the interface configuration file
    /etc/sysconfig/network-scripts/ifcfg-eth0 with the following parameters:
    BROADCAST, IPADDR, NETMASK, NETWORK (if some or all of these parameters
    are missing, they are set by this procedure).

    Arguments:

        ipANDmask - a tuple of (IP_address, IP_mask), both must be in the dotted IP format
    """

    global ALREADYUPDATEDLIST
    # Read a configuration file for a first ethernet interface
    # detected by the _getIntfCfgFile procedure
    # (presumably /etc/sysconfig/network-scripts/ifcfg-eth0)
    file1    = RHELCFGFILES [4]
    f1Cont   = file (file1).read().strip()

    if ipANDmask:

        # We are in the "set" mode
        # ------------------------

        # Get IP address and IP mask
        ipAddr, ipMask = ipANDmask
        addrLst = ipAddr.split('.')
        maskLst = ipMask.split('.')
        #print '\nipANDmask = %s, addrLst = %s, maskLst = %s\n' % (str(ipANDmask), str(addrLst), str(maskLst))

        # Construct network address
        netwAddr  = '.'.join([str(int(addrLst[i]) &        int(maskLst[i]))  for i in range(4)])

        # Construct broadcast address
        broadAddr = '.'.join([str(int(addrLst[i]) | (255 - int(maskLst[i]))) for i in range(4)])
        
        for reStr, key, val in [
            (reIPADDR,  'IPADDR',    ipAddr),
            (reIPMASK,  'NETMASK',   ipMask),
            (reBROAD,   'BROADCAST', broadAddr),
            (reNETWORK, 'NETWORK',   netwAddr)]:
            if reStr.search (f1Cont):
                f1Cont = reStr.sub ('%s=%s' % (key, val), f1Cont)    # replace parameter ...
            else:
                f1Cont = f1Cont.strip () + '\n%s=%s' % (key, val)    # add parameter ...

        # Write a new content of the /etc/sysconfig/network-scripts/ifcfg-eth<n> file
        file (file1, 'w').write(f1Cont)
        # Remember what we had updated 	 
        ALREADYUPDATEDLIST.append ('ip') 	 
  	 
    else: 	 
        # We are in the "get" mode 	 
        # ------------------------ 	 

        # Just return host's IP address only (!) from the interface configuration file 	 
        mObj = reIPADDR.search(f1Cont) 	 
        if not mObj: 	 
            ipaddr=''
        else:
            ipaddr=mObj.group(1)
        return ipaddr


def netmask ():
    """
    Gets IP mask of the host from a first interface configuration file
    read by the procedure (presumably the file /etc/sysconfig/network-scripts/ifcfg-eth0).
    Only single ethernet interface is currently supported.
    """
    mObj = reIPMASK.search(file (RHELCFGFILES [4]).read())
    if not mObj:
        netmask=''
    else:
        netmask=mObj.group(1)
    return netmask

def mailadmin (newVal=None):
    """
    Gets/sets email address for root from /etc/aliases.
    """


    # Read the file: /etc/sysconfig/network
    file1    = '/etc/aliases'
    f1Cont   = file (file1).read()

    if newVal:

        # We are in the "set" mode
        # ------------------------
        
        if reMAILADMIN.search (f1Cont):
            f1Cont = reMAILADMIN.sub ('root: %s' % newVal, f1Cont)
        else:
            f1Cont = f1Cont.strip() + '\nroot: %s' % newVal

        # Write a new content of the file /etc/aliases
        file (file1, 'w').write(f1Cont)
        
    else:

        ret=''
        mObj = reMAILADMIN.search(f1Cont)
        if not mObj:
	    ret=''
	else:
	    ret=mObj.group(1)
	    
        return ret

def gateway (newVal=None):
    """
    Gets/sets IP address of the gateway from/to the /etc/sysconfig/network file.
    """

    global ALREADYUPDATEDLIST

    # Read the file: /etc/sysconfig/network
    file1    = RHELCFGFILES [0]
    f1Cont   = file (file1).read()

    if newVal:

        # We are in the "set" mode
        # ------------------------
        
        # Replace or add the line "GATEWAY=..." with the new gateway name
        # in content of the file: /etc/sysconfig/network
        if reGATEWAY.search (f1Cont):
            f1Cont = reGATEWAY.sub ('GATEWAY=%s' % newVal, f1Cont)
        else:
            f1Cont = f1Cont.strip() + '\nGATEWAY=%s' % newVal

        # Write a new content of the file /etc/sysconfig/network
        file (file1, 'w').write(f1Cont)
        
        # Remember what we had updated
        ALREADYUPDATEDLIST.append ('gateway')
        
    else:

        # We are in the "get" mode
        # ------------------------

        # Just return a current GATEWAY value from the file /etc/sysconfig/network
        mObj = reGATEWAY.search(f1Cont)
        if not mObj:
            gateway=''
        else:
            gateway=mObj.group(1)
        return gateway

def nameserver (newVal=None):
    """
    Gets/sets IP address of the DNS server from/to the /etc/resolv.conf file.
    """

    global ALREADYUPDATEDLIST

    # Read file: /etc/resolv.conf
    file1       = RHELCFGFILES [2]
    f1Cont      = file (file1).read()

    if newVal:
        
        # We are in the "set" mode
        # ------------------------

        # Replace or add the line "nameserver ..." with the new DNS name
        # in content of the file: /etc/resolv.conf
        if reDNSNAME.search (f1Cont):
            f1Cont = reDNSNAME.sub ('nameserver %s' % newVal, f1Cont)
        else:
            f1Cont = f1Cont.strip() + '\nnameserver %s' % newVal
            
        # Write a new content of the file /etc/resolv.conf
        file (file1, 'w').write (f1Cont)
        
        # Remember what we had updated
        ALREADYUPDATEDLIST.append ('nameserver')
        
    else:

        # We are in the "get" mode
        # ------------------------

        # Just return a current DNS value from the file: /etc/resolv.conf
        mObj = reDNSNAME.search(f1Cont)
        if not mObj:
            dnsname=''
        else:
            dnsname=mObj.group(1)
        return dnsname

def password (newVal=None):
    """Sets a new root password (in the GET mode always returns asterisks)"""

    global ALREADYUPDATEDLIST

    hiddenPassw = '******'

    if newVal:

        # We are in the "set" mode
        # ------------------------
        
        # Prevent from setting a hidden value (all asterisks)
        if newVal != hiddenPassw:

            # Replace root password
            outRep = commands.getoutput ('echo %s | passwd --stdin root' % newVal)
            
            if outRep.find('updated successfully') < 0:
                raiseCleanExit ( 'Failed to update root password to the new one: %s' % newVal )

            # Remember what we had updated
            ALREADYUPDATEDLIST.append ('password')
            
    else:

        # We are in the "get" mode
        # ------------------------

        # Always return the hidden string value
        return hiddenPassw

def timezone (newVal=None):
    """
    Gets/sets timezone from/to the file /etc/sysconfig/clock.
    In the SET mode, the procedure also makes a softlink to the right file
    in the /usr/share/zoneinfo directory.
    """

    global ALREADYUPDATEDLIST

    locTime = '/etc/localtime'

    # Read the file: /etc/sysconfig/clock
    file1   = RHELCFGFILES [3]
    f1Cont  = file (file1).read()

    if newVal:
        
        # We are in the "set" mode
        # ------------------------
        
        # Determine a timezone file name
        zoneFile = '%s/%s' % (ZONEDIR, newVal)

        # Check if a new timezone value is legitimate
        if not os.path.exists (zoneFile) or not os.path.isfile (zoneFile):
            raiseCleanExit( '\n*** Error: incorrect timezone data "%s"' % newVal )

        # Replace or add the line "ZONE=..." with the new zone name
        # in content of the file: /etc/sysconfig/clock
        if reZONE.search (f1Cont):
            f1Cont = reZONE.sub ('ZONE="%s"' % newVal, f1Cont)
        else:
            f1Cont = f1Cont.strip() + '\nZONE=%s' % newVal
            
        # Write a new content of the file /etc/sysconfig/clock
        file (file1, 'w').write (f1Cont)
            
        # Make a softlink from a timezone file to /etc/localtime
        if os.path.exists (locTime): os.remove (locTime)
        cmdoutput=commands.getoutput ('ln -s %s %s' % (zoneFile, locTime))
        log_printout (cmdoutput)
        # Remember what we had updated
        ALREADYUPDATEDLIST.append ('timezone')
        
    else:
        # We are in the "get" mode
        mObj = reZONE.search (f1Cont)
        if not mObj:
            errMsg = 'incorrect format of the %s file: no ZONE detected' % file1
            raiseCleanExit ( '\n*** Error: %s ***\n' % errMsg )
        return mObj.group(1)

def _ssl ():
    """
    This procedure is for generating and installing a new self-signed SSL cerificate.
    """
    genSsl      = '/usr/bin/ssl-cert/gen-ssl-keys.sh'
    instSsl     = '/usr/bin/ssl-cert/install-cert.sh'
    keyPassw    = 'changeit'
    storeDir    = '/tmp/sipX'
    cfgScript   = '/usr/bin/sipxpbx-config'

    cmdoutput=commands.getoutput ('rm -f %s/*.crt' % storeDir)
    log_printout (cmdoutput)
    cmdoutput=commands.getoutput ('rm -f %s/*.key' % storeDir)
    log_printout (cmdoutput)
    cmdoutput=commands.getoutput ('rm -f %s/*.ser' % storeDir)
    log_printout (cmdoutput)
    cmdoutput=commands.getoutput ('rm -f %s/*.csr' % storeDir)
    log_printout (cmdoutput)
    if not os.path.exists (storeDir): cmdoutput=commands.getoutput ('mkdir -p %s' % storeDir)
    log_printout (cmdoutput)
    curDir = os.getcwd ()
    os.chdir (storeDir)
    uniqueStr = ('%.6f' % time.time())[-4:]
    hostName  = commands.getoutput ('hostname -f')
    sipxVers  = commands.getoutput ('%s --version' % cfgScript).split('.')
    try:
        sipxVers[0] = int (sipxVers[0])
        sipxVers[1] = int (sipxVers[1])
    except:
        sslLog  = '\n*** Failed to detect a numeric SIPX version/subversion '
        sslLog += 'from the SIPX version signature "%s". ' % '.'.join (sipxVers)
        sslLog += 'Therefore unable to install SSL certificate. ***\n'
        raiseCleanExit ( sslLog )

    # Generate a key
    cmd  = '%s <<EOF 2>/dev/null >/dev/null' % genSsl
    cmd += '\nUS'                              # Country Name (2 letter code)
    cmd += '\nAnyState'                        # State or Province Name (full name)
    cmd += '\nAnyCity'                         # Locality Name (eg, city)
    cmd += '\nAnyCompany'                      # Organization Name (eg, company)
    cmd += '\nAnyDepartment'                   # Organization Unit Name (eg, section)
    cmd += '\nca%s.%s' % (uniqueStr, hostName) # CA Common Name (DNS name for CA)
    cmd += '\nroot@ca%s.%s' % (uniqueStr, hostName)    # Email Contact Address for CA (name@example.org)
    cmd += '\n%s' % commands.getoutput ('hostname -d') # SIP domain name
    cmd += '\n%s' % hostName                           # Full DNS name for the server
    cmd += '\nroot@ca%s.%s' % (uniqueStr, hostName)    # Email Contact Address for Server
    cmd += '\nEOF\n'
    os.system ('export PAGER=cat; %s' % cmd)

    # Install a new SSL certificate
    cmdoutput=commands.getoutput (instSsl)
    log_printout (cmdoutput)
    #if commands.getoutput (cmd).find ('SSL security is now configured.') < 0:
    #    raise Exception, 'Failed to install SSL ceritificate'
    os.chdir (curDir)

def _ntpConfig ():
    """Procedure to (re)configure NTP"""
    # Known NTP servers:
    NTPSRVLST_US = ['0.us.pool.ntp.org', '1.us.pool.ntp.org', '2.us.pool.ntp.org']
    NTPSRVLST_NON_US = ['0.pool.ntp.org', '1.pool.ntp.org', '2.pool.ntp.org']
    NTPSRVLST = NTPSRVLST_US
    
    ntpConf  = '\n# A client-only ntp configuration'
    ntpConf += '\n# -------------------------------\n'
    ntpConf += '\n# Deny-by-default policy'
    ntpConf += '\nrestrict default ignore\n'
    ntpConf += '\n# Permit all access over the loopback interface'
    ntpConf += '\nrestrict 127.0.0.1\n'
    ntpConf += '\n# Local fudge if network servers are not available'
    ntpConf += '\nserver 127.127.1.0'
    ntpConf += '\nfudge  127.127.1.0 stratum 10\n'
    ntpConf += '\nauthenticate no'
    ntpConf += '\nrestrict 127.0.0.0 mask 255.0.0.0 nomodify nopeer noquery notrap'
    ntpConf += '\ndriftfile /var/lib/ntp/drift\n'

    #--- Make sure that NTP daemon has been installed
    if not commands.getoutput('rpm -qa | grep ntp').strip():
        log_printout( '\n*** Error: NTP is not detected on this host ***\n')
        return

    #--- Create /etc/ntp.conf

    ntpConf += '\n# Synchronize with selected time servers'
    for srvName in NTPSRVLST:
        ntpConf += '\nserver %s' % srvName
    file ('/etc/ntp.conf', 'w').write ('%s\n' % ntpConf)

    #--- Create /etc/ntp/step-tickers
    
    file ('/etc/ntp/step-tickers', 'w').write ('\n'.join (NTPSRVLST))

    #--- Remove /etc/ntp/ntpservers

    try:    os.remove ('/etc/ntp/ntpservers')
    except: pass

    #--- Turn on the ntpd service on runlevel 3

    cmdoutput=commands.getoutput ('/sbin/chkconfig --level %d ntpd on' % RUNLEVEL)
    log_printout (cmdoutput)

    #--- Synchronize the clock and start NTP service

    cmdoutput=commands.getoutput ('/sbin/service ntpd start')
    log_printout (cmdoutput)

def _getListOfTimeZones ():
    """
    Procedure searches for all pre-configured timezone files in the /usr/share/zoneinfo
    directory and returns an alphabetically sorted list of all time zone names supported
    on this platform.
    """

    reZONENAME = sre.compile ('^[A-Z][a-z][^0-9+-]+$')

    curDir = os.getcwd ()
    os.chdir (ZONEDIR)
    tmpLst  = commands.getoutput ('egrep -rl "^TZif" *').split()
    zoneLst = [x for x in tmpLst if reZONENAME.search (x)]
    zoneLst.sort ()
    os.chdir (curDir)
    return zoneLst

def saveSipxCfg ():
    """
    This procedure saves a pristine SIPX configuration (for SIPX versions
    later than 3.0) as a tar archive in the recovery partition. It uses
    current archives in the /var/sipxdata/upgrade directory to figure out
    which paths need to be saved in a SIPX configuration tarball in /recovery/cfg.
    """

    sipxSaveCfgDir = '%s/cfg' % RECROOTDIR
    if not os.path.exists (sipxSaveCfgDir):
        cmdoutput=commands.getoutput ('mkdir %s' % sipxSaveCfgDir)
        log_printout (cmdoutput)

    #--- Saving SIPX configuration: list of SIPX configuration files
    #    is dynamically retrieved from current archives in /var/sipxdata/upgrade
    arcDir = '/var/sipxdata/upgrade'
    if not os.path.exists (arcDir):
        raiseCleanExit ( 'Failed to located the %s directory' % arcDir )
    arcLst = glob.glob ('%s/*current.tgz' % arcDir)
    if not arcLst:
        raiseCleanExit ( 'Failed to locate "*current.tgz" files in the %s directory' % arcDir )
    cfgLst = list ()
    for arcName in arcLst:
        for cfgFile in commands.getoutput ('tar -ztf %s' % arcName).split ():
            if cfgFile [-1] == '/': continue
            cfgLst.append ('/%s' % cfgFile)
                
    sipxFDarchive = '%s/pristine_sipx.tgz' % sipxSaveCfgDir
    statStr, outStr = commands.getstatusoutput (
        'tar -zcPpf %s --same-owner %s' % (sipxFDarchive, ' '.join (cfgLst)))
    if outStr:
        errMsg  = '\n*** Warning: creating SIPX factory configuration archive '
        errMsg += 'resulted in the following output:\n\n%s\n' % outStr
        log_printout (errMsg)
    cmdoutput=commands.getoutput ('chmod 444 %s' % sipxFDarchive)
    log_printout (cmdoutput)
    #print '\tDone with SIPX factory configuration'
    
#======================================================================
# MAIN SCRIPT BODY STARTS HERE
#======================================================================

#--- Get command line arguments

log_init()
screen_init()

cmdOpt = dict()
for optStr in reCMDOPT.split ( ' '.join (sys.argv[1:]) ):
    if not optStr.lstrip(): continue
    i = optStr.find (' ')
    if i < 0:
        cmdOpt [optStr] = True
    else:
        val = optStr[i:].strip()
        try:    val = int (val)
        except: pass
        cmdOpt [optStr[:i]] = val
if 'h' in cmdOpt or 'help' in cmdOpt:
    raiseCleanExit ( hlpMsg )

log_printout ( '\n--- Reconfiguring linux networking parameters ---\n')

#--- Check prerequisites for running this script

fmtRep = '\t%-30s : %s'

# Root user should run this script
if os.getenv ('LOGNAME') != 'root':
    raiseCleanExit ( '\n*** Error: you must be "root" user in order to run this script\n' )
log_printout (fmtRep % ('Root user', 'Ok'))

# Recovery partition should exist
if not os.path.exists (RECROOTDIR):
    raiseCleanExit ( '\n*** Error: unable to locate the recovery partition: %s\n' % RECROOTDIR )
log_printout( fmtRep % ('Recovery partition', 'Detected'))

# RPMS directory in recovery partition should exist
rpmDir      = commands.getoutput ('find %s -name RPMS' % RECROOTDIR)
if not rpmDir:
    raiseCleanExit ( '\n*** Error: failed to locate RPMS directory in %s\n' % RECROOTDIR )
log_printout ( fmtRep % ('RPMS directory', 'Detected'))


try:
    # --- Detect current linux networking parameters 	 
    ifCfgFile = '%s/ifcfg-%s' % (IFCONFIGDIR, ETHNAME) 	 

    RHELCFGFILES.append (ifCfgFile) 	 
  	 
    curVal = dict () 	 
    lngCur  = 32
    for key in RHELCFGLIST: 	 
        curVal [key] = eval ('%s ()' % key)
        log_printout('existing key %s val %s' % ( key, curVal [key]))
        lngCur       = max  (lngCur, len (curVal [key])) # (for formatting purposes)
  
    #--- Inquire about new network parameters

    log_printout ( '\n\tPlease enter network parameters:\n')
    fmt    = '\t\t%%-12s [%%%ds] : ' % lngCur
    newVal = dict ()
    
    newVal=screen_ask_net(curVal)
    
    ntpFlag=screen_ask_ntp()
    
    newVal['timezone']=screen_ask_tz(curVal['timezone'])
    
    
    #--- Confirm all changes

    fmt     = '\n\t%%-15s   %%-%ds   %%s' % max (lngCur, 13)
    txtMsg  = '\n'   + fmt % ('Parameter', 'Current Value', 'New Value')
    txtMsg += '\n\t' + 70*'-'
    for key in RHELCFGLIST:
        if newVal [key] == curVal [key]:
            txt1 = '--- no change ---'
            del newVal [key]
        else:
            txt1 = newVal [key]
        txtMsg += fmt % (key.capitalize(), curVal [key], txt1)
    if ntpFlag: txt1 = 'configure'
    else:       txt1 = '--- no change ---'
    tmpOut = commands.getoutput ('/sbin/chkconfig --list | grep ntpd')
    log_printout ( 'NTPD:%s' % tmpOut)
    if tmpOut and tmpOut.find ('3:on') > 0: txt0 = 'yes'
    else:                                   txt0 = 'no'
    txtMsg += fmt % ('NTP', txt0, txt1)
    if newVal:
        txtMsg += '\n\n\tWARNING: this is your last chance to avoid changes in parameters'
        txtMsg +=   '\n\t         Please select "yes" if you want to proceed'
        txtMsg +=   '\n\t         with the changes: '
    else:
        txtMsg += '\n\n\tWARNING: there are no changes requested in parameters.'
        txtMsg +=   '\n\t         Please select "yes" if you want to proceed'
        txtMsg +=   '\n\t         with the Sipx installation: '
    exitFlag = False
    
    # confirm graphics
    exitFlag=screen_ask_confirm(curVal, newVal, ntpFlag)
    if (exitFlag == 0) :
        raiseCleanExit ( '*** Script interrupted, no changes have been made ***' )

    # installer progress bar
    
    screen.popWindow()
    pb = snack.Scale(40,150)

    sg = snack.GridForm(screen, 'Installing...', 1, 1)
    sg.add(pb, 0, 0, (1, 1, 1, 1))
    sg.draw()

    progress(1)
    #--- Replace linux networking parameters with new values and restart network
    
    if newVal:
        if newVal.has_key ('ip') or newVal.has_key ('netmask'):
            if newVal.has_key ('ip'):
                ipAddr = newVal ['ip']
                del newVal ['ip']
            else:
                ipAddr = curVal ['ip']
            if newVal.has_key ('netmask'):
                ipMask = newVal ['netmask']
                del newVal ['netmask']
            else:
                ipMask = curVal ['netmask']
            newVal ['ip'] = (ipAddr, ipMask)
        for key in newVal:
            eval ('%s (newVal ["%s"])' % (key, key))
        if newVal.keys () != ['password']:
            cmdoutput=commands.getoutput ('/sbin/service network restart')
            log_printout (cmdoutput)
    
    progress(10)
    #--- NTP
    if admin_email:
    	mailadmin(admin_email)
    	#cmdoutput=commands.getoutput ("echo \# Person who should get roots mail >>/etc/aliases ")
    	#log_printout (cmdoutput)
    	#cmdoutput=commands.getoutput ('echo root: %s >>/etc/aliases ' % admin_email)
    	#log_printout (cmdoutput)

    progress(15)
    
    if ntpFlag:
        log_printout ( '\n--- Configuring NTP ---\n' )
        _ntpConfig ()
    
    progress(20)

    #--- PostgreSQL
    
    log_printout ( '\n--- Starting PostgreSQL server ---\n' )

    cmdoutput=commands.getoutput ('chkconfig --level %d postgresql on' % RUNLEVEL)
    progress(30)
    log_printout (cmdoutput)
    if commands.getoutput ('chkconfig --list | grep postgre').find ('%d:on' % RUNLEVEL) < 0:
        raiseCleanExit ('*** PostgreSQL server not found')
        
    cmdoutput=commands.getoutput ('/sbin/service postgresql start')
    progress(40)
    log_printout (cmdoutput)

    #--- Installing SSL certificate

    log_printout ( '\n--- Installing a default self-signed SSL certificate ---\n' )
    _ssl ()
    progress(120)

    #--- Saving SIPX pristine configuration

    log_printout ( '\n--- Saving pristine SIPX configuration ---\n' )
    try:   saveSipxCfg ()
    except Exception, d:
        log_printout ('\n*** Error: failed to save a pristine sipx configuration: %s\n' % str (d) )

    progress(150)
    
    screen_completed()
    #--- Rebooting the host

    log_printout ( '\n--- Rebooting the host (you have 10 secs to use Ctrl+C for interruption) ---\n' )
    time.sleep (2)
    cmdoutput=commands.getoutput  ('reboot')
    log_printout (cmdoutput)
    log_printout ( '\n=== DONE ===\n' )
    log_destroy()
        
except:

    excType, excData, excTrace = sys.exc_info()
    if   excType == KeyboardInterrupt:
        log_printout ( '\n\n*** User Interruption Detected ***\n\n' )
    elif excType == SystemExit:
        log_printout ( '\n%s\n' % str (excData) )
    else:
        errStack = traceback.extract_tb(excTrace)[-1]
        errMsg   = '\nUNEXPECTED EXCEPTION CAPTURED:\n\n'
        errMsg  += '%s: %s ' % (str(excType), str(excData))
        errMsg  += '(exception occured in file: %s, line: %s)\n' % (errStack[0], errStack[1])
        log_printout ( errMsg )
    screen.finish()

